First thing to do is create the lists of index numbers.
LeftArc: 7 sets of seven numbers
RightArc: 7 sets of seven numbers
Ring: 7 sets of seven numbers

Note: these are three ways to represent the same gameboard, which has 49 spots on it.

Easiest way to do this would be to print off a blank lotus sudoku and fill in the index numbers. I'm sure there is a mathematical pattern for all of the sets. In Haskell, the lists can probably be generated by list comprehensions.

Next, start generating numbers. Start with LeftArc. Add one random number from 1 to 7 to each set.

Then RightArc; check each set to see if there's already a number; if so, skip it. If not, generate a random number that isn't already in the set. At this point there should be one number in each set in RightArc.

Then Ring. Again, check to see if every ring has one and only one number in it. If not, generate one that doesn't violate the conditions for the LeftArc or RightArc.

At the end of this cycle, every set should have one and only one number in it. There will now be a total of seven numbers chosen on the gameboard. Then proceed to the next cycle, where a second number is progressively chosen for each set that doesn't violate the conditions for the other sets.

The key questions here are how to set up the data structure, and how to check for conflicts. Haskell has fantastic support for sets. This is clearly a sets problem. Maybe make use of union and/or intersection to check for conflicts.

I think we need to start off with the sets described above. These are just lists, single value. Then, as we generate new items, we add them to a single set of tuples that represents the solution. The tuples are structured like this: (index, value), where index is from 0-48 and value is from 1-7.

For each list, we take the intersection of the reference set and the solution set. For example, the intersection of LeftArc set #1 and the solution set. The tuples from the solution set should be returned. The count of the result will tell us whether we need to generate a number. If we do, we pick a number from 1-7 that isn't already in the solution set; check it against the values in the tuples. Then, pick an index from the reference set that, again, isn't already used.

Now it gets tricky. We need to check that the tuple we just generated doesn't violate the conditions for the other two sets. It's important at this point to realize that every index in the solution set is a member of exactly three total reference sets. We need a way to look up the other two reference sets and check that the value in our tuple isn't already in either set.

To do this, we use the index number. (Back to our LeftArc example.) We look at each of the 7 RightArc sets to see if it is a member. If it is, we get the intersection of that set with the solution set and check to see if the value we generated is in that list of values. If it isn't, we're good. Do the same for Ring. If we find that the value we generated is already in one of the other sets for that index, we generate a new index and value in our original set and try again. Now that I think about it, it would actually be better to use an exhaustive iteration of the possible indexes and values in the original set instead of randomizing.

A possible good first step would be to write a function that proves the correctness of a solution. I.e., you've generated something; is it right? This would be the final step of the program.

This is going to work!! Next steps will be to investigate the syntax of sets and set operations in Haskell.

I've also been contemplating writing a JS frontend that would display the solution on a lotus gameboard. That would be fun if I could do it without too much effort. 
