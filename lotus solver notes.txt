First thing to do is create the lists of index numbers.
LeftArc: 7 sets of seven numbers
RightArc: 7 sets of seven numbers
Ring: 7 sets of seven numbers

Note: these are three ways to represent the same gameboard, which has 49 spots on it.

Easiest way to do this would be to print off a blank lotus sudoku and fill in the index numbers. I'm sure there is a mathematical pattern for all of the sets. In Haskell, the lists can probably be generated by list comprehensions.

Next, start generating numbers. Start with LeftArc. Add one random number from 1 to 7 to each set.

Then RightArc; check each set to see if there's already a number; if so, skip it. If not, generate a random number that isn't already in the set. At this point there should be one number in each set in RightArc.

Then Ring. Again, check to see if every ring has one and only one number in it. If not, generate one that doesn't violate the conditions for the LeftArc or RightArc.

At the end of this cycle, every set should have one and only one number in it. There will now be a total of seven numbers chosen on the gameboard. Then proceed to the next cycle, where a second number is progressively chosen for each set that doesn't violate the conditions for the other sets.

The key questions here are how to set up the data structure, and how to check for conflicts. Haskell has fantastic support for sets. This is clearly a sets problem. Maybe make use of union and/or intersection to check for conflicts.

I think we need to start off with the sets described above. These are just lists, single value. Then, as we generate new items, we add them to a single set of tuples that represents the solution. The tuples are structured like this: (index, value), where index is from 0-48 and value is from 1-7.

For each list, we take the intersection of the reference set and the solution set. For example, the intersection of LeftArc set #1 and the solution set. The tuples from the solution set should be returned. The count of the result will tell us whether we need to generate a number. If we do, we pick a number from 1-7 that isn't already in the solution set; check it against the values in the tuples. Then, pick an index from the reference set that, again, isn't already used.

Now it gets tricky. We need to check that the tuple we just generated doesn't violate the conditions for the other two sets. It's important at this point to realize that every index in the solution set is a member of exactly three total reference sets. We need a way to look up the other two reference sets and check that the value in our tuple isn't already in either set.

To do this, we use the index number. (Back to our LeftArc example.) We look at each of the 7 RightArc sets to see if it is a member. If it is, we get the intersection of that set with the solution set and check to see if the value we generated is in that list of values. If it isn't, we're good. Do the same for Ring. If we find that the value we generated is already in one of the other sets for that index, we generate a new index and value in our original set and try again. Now that I think about it, it would actually be better to use an exhaustive iteration of the possible indexes and values in the original set instead of randomizing.

A possible good first step would be to write a function that proves the correctness of a solution. I.e., you've generated something; is it right? This would be the final step of the program.

This is going to work!! Next steps will be to investigate the syntax of sets and set operations in Haskell.

I've also been contemplating writing a JS frontend that would display the solution on a lotus gameboard. That would be fun if I could do it without too much effort.

***

4/26/16

Spent several hours this afternoon thinking through the problem.

main:
a do statement. This will be the only IO section of the code. Solicits input from user "How many solutions do you want?"
Gets an infinite list of random numbers from 1-7.
Generates the ref tree and reflists.
Calls generateSolution as many times as the user requests, validates the solution and prints the solution to the console after each iteration

generateSolution::[[(Int, Int)]] -> [[[Int]]] -> [(Int, Int)] -> [Int] -> [Int]
generateSolution reflists reftree solboard randoms =

Attempts to add a number to the solboard for the reflist. Processes all 21 reflists, then calls itself again as many times as necessary until either the process fails or a solution is found. Returns a list of values ordered by index.

processReflists::[(Int, Int)] [[[Int]]] -> [(Int, Int)] -> [Int, [Int], [(Int, Int)]]
processReflists reflists reftree solboard randoms =

addVal::
addVal reflist reftree solboard randoms lastResult
  | (lastResult = 0) =
  |

returns a list with a return status and the modified randoms list and the solboard. Possible statuses are : failed, add successful, or list already full. We will use 0, 1 and 2 to represent these. Function will repeat until the the final sum of all the return values is equal to 42, or a failed status is returned.

Maybe I need a game datatype of some kind. Gamestate needs to be passed to every function we use, and dealing with five parameters for every function gets a bit old.
Gamestate data:
reflist, reftree (original unmodified)
randoms (current value, used values discarded)
solboard
status: in progress, solution found, or failed. methods check this to see whether to continue. May just use boolean in progress or failed

Only randoms and solboard will be modified within the gamestate. reflist will be used as a reference to pull out when functions need to be restarted (either that, or we can just use global variables).

Let's try this again.

generateSolution::
generateSolution reflists gamestate
  | gamestate status == inprogress = processReflists reflists gamestate
  | gamestate status == failed = generateSolution reflists (reset gamestate) -- or print "solution not found"

processReflists::
processReflists reflists gamestate
  | gamestate status == inprogress = addVal re
  | gamestate status == failed = gamestate

addVal::reflist -> gamestate -> (result, gamestate)
addVal reflist gamestate
  | gamestate status == failed = (failed, gamestate)
  | gamestate status == inprogress = (if length listdiff > 0 then (addSol (listdiff !! 0) []) else (full, gamestate))
  where listdiff = (reflist - (intersectSolboard reflist solboard))

intersectSolboard
intersectBy (\(i,val) (index,value) -> i == index) solboard reflist

addSol listel solutionsTried
if (checkReftree candVal) then append candVal to solboard else failed
where candVal = ((fst listel), randVal))
--need to keep track of unique values tried. When we reach seven, we return failed
--probably just have addSol call itself until failure or success happens. Return (status, gamestate).

checkReftree
calls itself until each reflist has been checked, like so:
  | (elem (snd candVal) (intersectSolboard solboard reflist) = False --If the value is already in one of the lists, return false
  | otherwise = True
where reflists = (reftree !! (fst candVal))

randVal
returns first item in randoms, trims it from randoms list in gamestate

***

example refTree:
[[],[],[],[],[],[],[[0..6],[6,13,14,21,29,36,44],[6,12,19,25,32,38,45]]]
refTree !! 6 gives one list each from Ring, LeftArc, and RightArc. Put in a number, get the related lists. Will need to generate this, or just set it up manually.

reflists: zip the refboards from validateLotus into tuples (1,0), (2,0), etc, the second item is a dummy number which will never be used. Needs to be preset so that it is the same type as solboard. Alternate ring, LArc, RArc, until all 21 have been added.

solboard: [(index, val), (0,3), (1,5), (etc)]
first number is index relating to position on board, second is number from one to seven

randoms: infinite list of random numbers from 1 to 7
